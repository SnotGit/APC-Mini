# PROMPT 2 - TECHNIQUE (Analyse & Refactorisation)

## üî¨ APPROCHE CHIRURGICALE : ANALYSER-TRIER-AM√âLIORER

### Principe fondamental
Le code existant est une **R√âF√âRENCE GLOBALE** pour comprendre l'application, PAS du code √† conserver tel quel. Votre mission est de faire une analyse intelligente pour cr√©er une version moderne et propre.

### M√©thodologie obligatoire
- **ANALYSER** le code existant pour identifier le bon vs le mauvais
- **CONSERVER** les m√©thodes/logiques bien √©crites et fonctionnelles
- **REFACTORISER** les parties sur-complexifi√©es ou redondantes
- **MODERNISER** ce qui est obsol√®te sans casser le fonctionnel
- **REPRODUIRE EXACTEMENT** l'apparence visuelle finale
- **REPARTIR** sur une base moderne en suivant la logique de r√©flexion utilisateur

## üìä PROCESSUS D'ANALYSE OBLIGATOIRE

### √âtape 1 : Inventaire complet
- **Lister** tous les fichiers du repository (HTML, CSS, JS, assets)
- **Identifier** les points d'entr√©e et fichiers principaux
- **Cartographier** la structure globale de l'application
- **R√©pertorier** les d√©pendances et modules utilis√©s

### √âtape 2 : Analyse fonctionnelle
- **Extraire** toutes les fonctionnalit√©s existantes
- **Identifier** les algorithmes et logiques m√©tier
- **Noter** les patterns d'interaction et comportements
- **Documenter** les structures de donn√©es utilis√©es

### √âtape 3 : Tri qualit√© du code
**√Ä CONSERVER (bonnes pratiques d√©tect√©es) :**
- ‚úÖ M√©thodes bien √©crites et lisibles
- ‚úÖ Logiques m√©tier pertinentes et efficaces
- ‚úÖ Algorithmes optimis√©s qui fonctionnent
- ‚úÖ Structures de donn√©es appropri√©es
- ‚úÖ Patterns corrects et r√©utilisables
- ‚úÖ Gestion d'erreurs robuste

**√Ä REFACTORISER (probl√®mes identifi√©s) :**
- ‚ùå Structure HTML sur-complexifi√©e (ex: 14 div pour 2 boutons)
- ‚ùå CSS redondant ou mal organis√©
- ‚ùå JavaScript dupliqu√© ou spaghetti
- ‚ùå Nommages incoh√©rents ou obscurs
- ‚ùå Patterns obsol√®tes ou anti-patterns
- ‚ùå Code mort ou comment√© inutilement

### √âtape 4 : Documentation du plan
- **Justifier** chaque choix de conservation vs refactorisation
- **Pr√©senter** l'architecture propos√©e
- **Expliquer** les am√©liorations techniques envisag√©es
- **Attendre** validation avant d√©veloppement

## ‚öôÔ∏è STANDARDS DE REFACTORISATION

## üéØ CONTRAINTE SIMPLICIT√â ABSOLUE

### Contexte mat√©riel
L'Akai APC Mini MK1 est un contr√¥leur MIDI **tr√®s simple et basique** :
- **64 pads (8x8)** avec tri-color LEDs 
- **9 faders** (8 tracks + master)
- **Quelques boutons** : Scene Launch, Clip Stop, Shift, navigation
- **USB powered**, plug & play avec Ableton Live

### Principe de simplicit√©
**C'est simple comme une t√©l√©commande de TV** ‚Üí l'app de configuration doit rester **proportionnellement simple**.

**INTERDICTION FORMELLE :**
- Sur-ing√©nierie ou complexification inutile
- Patterns avanc√©s non justifi√©s pour cette simplicit√©
- Architecture over-engineered pour des fonctions basiques
- Abstractions excessives pour du code straightforward

### Standards adapt√©s √† la simplicit√©
**HTML/CSS/JS basique et efficace :**
- Pas de frameworks complexes pour des interactions simples
- Pas de build tools ou compilation pour une petite app
- Code vanilla direct et compr√©hensible 
- Structure plate sans hi√©rarchies inutiles

## üîß AM√âLIORATIONS AUTORIS√âES

### Structure et organisation
- **Simplifier** la structure HTML over-engineered
- **Optimiser** le CSS redondant ou mal structur√©
- **Refactoriser** le JavaScript dupliqu√© ou mal organis√©
- **Moderniser** les patterns anciens (utiliser Grid, Flexbox, modules ES6)
- **R√©organiser** l'architecture des fichiers pour plus de clart√©

### Qualit√© technique
- **Corriger** les bugs techniques sans impact fonctionnel
- **Am√©liorer** les performances sans changer l'exp√©rience utilisateur
- **Optimiser** le chargement et la r√©activit√©
- **Standardiser** le code selon les bonnes pratiques actuelles

### Code maintenance
- **√âliminer** les duplications de code
- **Clarifier** les noms de variables et fonctions
- **Documenter** la logique complexe uniquement
- **Structurer** en modules logiques et r√©utilisables

## üéØ SYNTH√àSE REQUISE

### Combinaison intelligente
- **Meilleur du code existant** : conserver ce qui fonctionne bien
- **Logique de r√©flexion utilisateur** : respecter la vision architecturale
- **Standards modernes** : appliquer les bonnes pratiques actuelles
- **Base √©volutive** : cr√©er une fondation propre pour le futur

### Validation continue
- **Pr√©senter** l'analyse compl√®te avant d√©veloppement
- **Justifier** chaque d√©cision technique
- **Demander** confirmation pour les choix ambigus
- **Attendre** accord explicite avant de coder

## üìã LIVRABLES D'ANALYSE

### Document d'analyse requis
1. **Inventaire** : structure existante et fichiers
2. **Fonctionnalit√©s** : mapping complet des features
3. **Qualit√©** : tri d√©taill√© bon/mauvais code
4. **Plan** : architecture refactoris√©e propos√©e
5. **Justifications** : explications des choix techniques

### Validation obligatoire
- Pr√©sentation compl√®te de l'analyse
- Accord sur le plan de refactorisation
- Validation de l'architecture propos√©e
- Confirmation avant d√©but du d√©veloppement

**OBJECTIF :** Cr√©er une base de code moderne, maintenable et performante tout en pr√©servant l'exactitude fonctionnelle et visuelle de l'application existante.